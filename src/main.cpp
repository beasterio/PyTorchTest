#include <torch/torch.h>
#include <torch/script.h>

#include "VulkanGPUDevice.h"

#include <chrono>
#include <cmath>


namespace {
    constexpr auto kLocalGroupSize = 32;
}

int main() {
    // input data
    torch::Tensor geometry_parameters;
    torch::Tensor coords;
    torch::Tensor bps;
    torch::Tensor spheres;
    torch::Tensor sd_ground_truth;
    torch::Tensor grad_gt;

    // result data
    torch::Tensor d_y3_d_coords;
    torch::Tensor loss_l1_deriv;
    torch::Tensor positions;
    torch::Tensor nn_4th_layer;

    // result data, but generated by python
    torch::Tensor py_d_y3_d_coords;
    torch::Tensor py_loss_l1_deriv;
    torch::Tensor py_positions;
    torch::Tensor py_nn_4th_layer;

    try
    {
        // all input data is packed in packed_data.pt TorchScript model
        // the data available by key == filename
        auto container = torch::jit::load("packed_data.pt", torch::DeviceType::CPU);
        geometry_parameters = container.attr("geometry_parameters.pth").toTensor();
        coords = container.attr("coords.pth").toTensor();
        bps = container.attr("bps.pth").toTensor();
        spheres = container.attr("spheres.pth").toTensor();
        sd_ground_truth = container.attr("sd_ground_truth.pth").toTensor();
        grad_gt = container.attr("grad_gt.pth").toTensor();

        geometry_parameters = geometry_parameters[0];
        spheres = spheres[0];
        bps = bps[0];

        // coords is an array of vec3 values, all output data sizes should be the same
        const auto elements_num = coords.size(0);
        d_y3_d_coords = torch::zeros({ elements_num, 3 }, torch::kFloat32);
        loss_l1_deriv = torch::zeros(elements_num, torch::kFloat32);
        positions = torch::zeros({ elements_num, 16 }, torch::kFloat32);
        nn_4th_layer = torch::zeros(elements_num, torch::kFloat32);

        // reference data
        py_d_y3_d_coords = container.attr("d_y3_d_coords.pth").toTensor();
        py_loss_l1_deriv = container.attr("loss_l1_deriv.pth").toTensor();
        py_positions = container.attr("positions.pth").toTensor();
        py_nn_4th_layer = container.attr("nn_4th_layer.pth").toTensor();

        // remove useless size 1 dimension
        py_nn_4th_layer = py_nn_4th_layer.squeeze();
    }
    catch (std::exception& e)
    {
        std::cerr << "error loading the data\n";
        std::cerr << e.what() << "\n";
        return -1;
    }

    VulkanGPUDevice device;
    auto& shader = device.CreateShader("shaders/test.spv");

    // bind input buffers
    shader.AddBuffer(geometry_parameters);
    shader.AddBuffer(coords);
    shader.AddBuffer(bps);
    shader.AddBuffer(spheres);
    shader.AddBuffer(sd_ground_truth);
    shader.AddBuffer(grad_gt);

    //bind output bufferss
    const auto d_y3_d_coords_index = shader.AddBuffer(d_y3_d_coords);
    const auto loss_l1_deriv_index = shader.AddBuffer(loss_l1_deriv);
    const auto positions_index = shader.AddBuffer(positions);
    const auto nn_4th_layer_index = shader.AddBuffer(nn_4th_layer);

    shader.Bind();

    auto start = std::chrono::system_clock::now();
    const auto elements_num = coords.size(0);
    shader.Execute(elements_num / kLocalGroupSize + 1);
    shader.Wait();
    auto end = std::chrono::system_clock::now();

    shader.ReadBuffer(d_y3_d_coords_index, d_y3_d_coords);
    shader.ReadBuffer(loss_l1_deriv_index, loss_l1_deriv);
    shader.ReadBuffer(positions_index, positions);
    shader.ReadBuffer(nn_4th_layer_index, nn_4th_layer);

    // validate results
    float atol_eps = 1e-06;
    float rtol_eps = 1e-05;

    std::cout << "positions is " << (torch::allclose(positions, py_positions, rtol_eps, atol_eps) ? "ok" : "invalid") << std::endl;
    std::cout << "nn_4th_layer is " << (torch::allclose(nn_4th_layer, py_nn_4th_layer, rtol_eps, atol_eps) ? "ok" : "invalid") << std::endl;
    std::cout << "loss_l1_deriv is " << (torch::allclose(loss_l1_deriv, py_loss_l1_deriv, rtol_eps, atol_eps) ? "ok" : "invalid") << std::endl;

    // Seems pytorch calculate gradient in a bit different way, some values are not that accurate.
    std::cout << "d_y3_d_coords is " << (torch::allclose(d_y3_d_coords, py_d_y3_d_coords, rtol_eps, 0.01) ? "ok" : "invalid") << std::endl;

    std::cout << "Time to run compute shader: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;

    return 0;
}